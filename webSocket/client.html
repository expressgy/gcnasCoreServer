<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Client--测试WebRTC和信令</title>
</head>
<body>
<h1>我是浏览器端</h1>
<h2>
    <div>NAME</div>
    <div id="NAME"></div>
</h2>
<h2>
    <div>UUID :</div>
    <div id="UUID"></div>
</h2>
<div>
    <button id="CreateConnect">建立连接</button>
    <div>NasName<input id="NasName" type="text"></div>
</div>
</body>
<script>
    console.log('I AM Client')
    //  获取自身的识别码
    const Token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImV4cHJlc3NneSIsImlhdCI6MTY0ODEyODgyOTM2NCwiZXhwIjoyNTkyMDAwMDAwfQ.dIqVLBx__-uIN4QvINUUhBysDm9BxQrAWuGTD4j7YqY'
    document.querySelector('#NAME').innerText = Token
    console.log('Client : ', Token)

    function randomString(len) {
        len = len || 8;
        let $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678';    /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/
        let maxPos = $chars.length;
        let pwd = '';
        for (let i = 0; i < len; i++) {
            pwd += $chars.charAt(Math.floor(Math.random() * maxPos));
        }
        return pwd;
    }


    //  信令服务
    class signalling{
        //  WebSocket对象
        #ws
        //  心跳间隔时间
        #Timeout = 5000
        //  心跳包起始
        #heartNum = 0
        //  ws状态
        state = false
        //  获取到的自身的uuid
        #uuid
        //  连接上服务器时触发
        defaultIceConfig
        constructor(Token) {
            this.#ws = new WebSocket('ws://localhost:10001',Token);
            this.#ws.onerror = e => console.log('error',e)
            this.#ws.onopen = () => {
                //  握手交互
                this.#ws.send(JSON.stringify({type:'gy521'}))
                //  重置心跳包
                this.#heartNum = 0
                //  设置连接状态为正常
                this.state = true
                //  与服务器断开连接
                this.#ws.onclose = () => {
                    console.log('close')
                    //  将连接状态设置为错误
                    this.state = false
                }
            }
            this.#ws.onmessage = data => {
                let message = null;
                try{
                    //  将服务端数据转化为JSON格式
                    message = JSON.parse(data.data)
                }catch (e) {
                    //  如果不能转化为JSON格式，本次消息作废
                    console.log('非JSON字符',data.data)
                    return false
                }
                //  输出服务器的消息
                // console.log('Server Message',message)
                //  判断当前连接状态
                if(message.type != 'heart') console.log('Server Message',message)
                if(!this.state) return
                switch (message.type) {
                    case 'gy521':
                        //  开始
                        //  读取自身UUID
                        this.#uuid = message.uuid
                        this.defaultIceConfig = message.defaultIceConfig
                        document.querySelector('#UUID').innerText = this.#uuid
                        console.log('开始:', this.#uuid)
                        //  发送心跳起始包
                        this.#ws.send(
                            JSON.stringify({
                                type: 'heart',
                                heartNum:this.#heartNum
                            })
                        )
                        break
                    case 'heart':
                        //  心跳
                        //  判断心跳是否丢失
                        if (message.heartNum - 1 != this.#heartNum) {
                            console.log('系统故障，心跳丢失')
                            this.#ws.close()
                            return false
                        } else {
                            this.#heartNum += 2
                        }
                        //  设置延迟发送心跳包
                        setTimeout(() => {
                            this.#ws.send(
                                JSON.stringify({
                                    type: 'heart',
                                    heartNum: this.#heartNum
                                })
                            )
                        }, this.#Timeout)
                        break
                }
            }
        }
        //  主动关闭ws
        close(){this.#ws ? this.#ws.close() : false}
        getIceConfig(){return this.defaultIceConfig}
        createConnection(nasName){
            return new Promise(rec => {
                this.#ws.send(JSON.stringify({
                    type:'createConnection',
                    data:{
                        type:'request',
                        rtcName:new Date().getTime() + randomString(5),
                        master:nasName
                    }
                }))
                setTimeout(() => {
                    rec(false)
                },3000)
                const responseData = data => {
                    let message = null;
                    try{
                        //  将服务端数据转化为JSON格式
                        message = JSON.parse(data.data)
                    }catch (e) {
                        //  如果不能转化为JSON格式，本次消息作废
                        console.log('非JSON字符',data.data)
                        return false
                    }
                    if(message.type == 'createConnection'){
                        this.#ws.removeEventListener('message',responseData)
                        rec(message)
                    }
                }
                this.#ws.addEventListener('message',responseData)
            })
        }
        createRTC(master, offer, rtcName){
            return new Promise(rec => {
                this.#ws.send(JSON.stringify({
                    type:'createRTC',
                    data:{
                        type:'request',
                        rtcName,
                        from:this.#uuid,
                        to:master,
                        offer
                    }
                }))
                setTimeout(() => {
                    rec(false)
                },3000)
                const responseData = data => {
                    let message = null;
                    try{
                        //  将服务端数据转化为JSON格式
                        message = JSON.parse(data.data)
                    }catch (e) {
                        //  如果不能转化为JSON格式，本次消息作废
                        console.log('非JSON字符',data.data)
                        return false
                    }
                    if(message.type == 'createRTC'){
                        this.#ws.removeEventListener('message',responseData)
                        rec(message.data.answer)
                    }
                }
                this.#ws.addEventListener('message',responseData)
            })
        }
        sendICE(master, ice, rtcName){
            this.#ws.send(JSON.stringify({
                type:'ICE',
                device:'user',
                state:true,
                data:{
                    rtcName,
                    from:this.#uuid,
                    to:master,
                    ice
                }
            }))
        }
        onICE(master,callback){
            const responseData = data => {
                let message = null;
                try{
                    //  将服务端数据转化为JSON格式
                    message = JSON.parse(data.data)
                }catch (e) {
                    //  如果不能转化为JSON格式，本次消息作废
                    console.log('非JSON字符',data.data)
                    return false
                }
                if(message.type == 'ICE' && message.data.from == master){
                    callback(message.data.ice)
                }
            }
            this.#ws.addEventListener('message',responseData)
        }
    }
    //  RTC
    class userWebRTC{
        #iceConfig
        #mediaConfig = {
            offerToReceiveAudio : false,
            offerToReceiveVideo : false
        }
        #rtcConfig
        #RTC
        #channel
        constructor(defaultIceConfig,userIceConfig) {
            //  初始化iceConfig信息
            this.#iceConfig = [defaultIceConfig].concat(userIceConfig)
        }
        async #createHash(){
            //  为RTC加密
            return new Promise(async rec => {
                const generateConfig = {
                    name: 'RSASSA-PKCS1-v1_5',
                    hash: 'SHA-256',
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1])
                }
                const cert = await RTCPeerConnection.generateCertificate(generateConfig)
                this.#rtcConfig = {
                    certificates:[cert],
                    iceServers:this.#iceConfig
                }
                rec()
            })
        }
        async createRTC(){
            return new Promise(async rec => {
                await this.#createHash()
                this.#RTC = new RTCPeerConnection(this.#rtcConfig);
                this.#createDataChannel()
                // setInterval(()=>{
                //     console.log('iceConnectionState',this.#RTC.iceConnectionState)
                //     console.log('connectionState',this.#RTC.connectionState)
                // },1000)
                rec()
            })
        }
        #createDataChannel(){
            this.#channel = this.#RTC.createDataChannel('MyData');
            this.#channel.onopen = ()=>{
                console.log('DataChannel is Open')
                let heart = {
                    type:'P2PHEART'
                }
                const channelHeartInterval = setInterval(()=>{
                    this.#channel.send(JSON.stringify(heart))
                },1500)
            }

            this.#channel.onopen = ()=>{
                console.log('DataChannel is Open')
            }
        }
        makeOffer(){
            return new Promise(async rec => {
                try{
                    const offer = await this.#RTC.createOffer(this.#mediaConfig)
                    await this.#RTC.setLocalDescription(offer)
                    rec(offer)
                }catch (e) {
                    console.log('创建RTC：获取本地描述失败',e)
                }
            })
        }
        setAnswer(answer,callback){
            this.#RTC.setRemoteDescription(answer);
            this.#RTC.onicecandidate = callback
        }
        addIceCandidate(ice){
            this.#RTC.addIceCandidate(ice.candidate)
        }
    }

    async function start(){
        const sl = new signalling(Token)
//    开始业务
        const click = document.querySelector('#CreateConnect')
        const input = document.querySelector('#NasName')
        click.onclick = async event => {
            // const mubiaoNasName = input.value
            const mubiaoNasName = '52sswyxh6em4KByKAp4TrJBEfyb73Jts'
            const canConnection = await sl.createConnection(mubiaoNasName)
            if(!canConnection.data.state)return false
            const master = canConnection.data.master
            const rtcName = canConnection.data.rtcName
            //  进行点对点连接
            //  获取默认ICE配置
            const defaultIceConfig = sl.getIceConfig()
            //  初始化ICE配置
            const oneRTC = new userWebRTC(defaultIceConfig,[])
            //  创建RTC
            await oneRTC.createRTC()
            //  创建本地描述文件
            const offer = await oneRTC.makeOffer()
            //  发送描述文件
            const answer = await sl.createRTC(master, offer, rtcName)
            //  设置远端ICE，提前监听
            sl.onICE(master,ice => {
                oneRTC.addIceCandidate(ice)
            })
            //  设置远端description
            oneRTC.setAnswer(answer,data => {
                if(data.candidate){
                    //  开始交换ice信息
                    sl.sendICE(master, data, rtcName)
                }else{
                    console.log('ICE协商结束')
                }
            })
        }
    }

    start()



</script>
</html>